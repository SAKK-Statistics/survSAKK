} else if (segment.annotation == "top"){
if(stratum == 2){
text_ypos <- 0.85
} else {
text_ypos <- 0.9
}
text_xpos <- max(xticks)*0.5
pos <- 1
} else if (segment.annotation == "none"){
text_ypos <- NULL
text_xpos <- NULL
pos <- 2
} else {
stop(paste0("'",segment.annotation,"'"," is not a valid argument!"))
}
# Determining the y coordinate for the text of each arm
if (stratum > 1 & (segment.confint == T)){
text_ypos <- rep(text_ypos, stratum) + (stratum-1):0*segment.annotation.space
}
#----------------------------------------------------------------------------#
### 3.1.2 Preparation of the label ####
#----------------------------------------------------------------------------#
if(!is.null(segment.quantile) & is.null(segment.timepoint)){
# Code for segment at a specific quantile
segment_y <- segment.quantile
segment_x <- quantile(fit,probs = 1 - segment_y)
# Adjusting label of time.unit with sufix: s
if(!missing(time.unit)){
time.unit_temp <- paste0(" ", time.unit, "s")
} else {
time.unit_temp <- ""
}
# Short notation without confidence interval (only possible if number of arms = 2)
if(segment.confint == F & stratum == 2){
if(segment.quantile == 0.5) {quantile.temp <- "Median"}
else {quantile.temp <- paste0(segment.quantile, "-Quantile")}
quantile_label <- paste0(quantile.temp, ": ",
round(segment_x$quantile[1],digits = 1),
" vs ",
round(segment_x$quantile[2],digits = 1),
time.unit_temp)
segment.annotation.col <- "black"
# Error message if no confidence interval should be displayed but number of arms is not equal to 2
} else if(segment.confint == F & stratum != 2) {
stop("The parameter `segment.confint` cannot be set to FALSE when number of arms is unequal 2.")
# Long notation with confidence interval
} else {
quantile_label <- paste0(round(segment_x$quantile,digits = 1),
time.unit_temp,
" (",
round(segment_x$lower,digits = 1),
" to ",
round(segment_x$upper,digits = 1),
")")
}
}
if(is.null(segment.quantile) & !is.null(segment.timepoint)){
# Code for segment at a specific time point
segment_x <- segment.timepoint
segment_y <- summary(fit,time = segment_x)
# Short notation without confidence interval (only possible if number of arms = 2)
if(segment.confint == F & stratum == 2){
if(missing(time.unit)){time_temp <- paste0("time ", segment.timepoint)}
else {time_temp <- paste0(segment.timepoint, " ", time.unit, "s")}
if(y.unit == "percent"){
timepoint_label <- paste0("Survival at ", time_temp, ": ", round(segment_y$surv[1], digits = 3)*100,
"% vs ",
round(segment_y$surv[2], digits = 3)*100, "%")
} else {
timepoint_label <- paste0("Survival at ", time_temp, ": ", round(segment_y$surv[1], digits = 2),
" vs ",
round(segment_y$surv[2], digits = 2))
}
segment.annotation.col <- "black"
# Error message if no confidence interval should be displayed but number of arms is not equal to 2
} else if(segment.confint == F & stratum != 2) {
stop("The parameter `segment.confint` cannot be set to FALSE when number of arms is unequal 2.")
# Long notation with confidence interval
} else {
if(y.unit == "percent"){
timepoint_label <- paste0(round(segment_y$surv, digits = 3)*100,
"% (95% CI: ",
round(segment_y$lower, digits = 3)*100,
" to ",
round(segment_y$upper, digits = 3)*100,
")")
} else {
timepoint_label <- paste0(round(segment_y$surv, digits = 2),
" (95% CI: ",
round(segment_y$lower, digits = 2),
" to ",
round(segment_y$upper, digits = 2),
")")
}
}
}
if(!is.null(segment.quantile) & !is.null(segment.timepoint)){
stop(paste0("The parameters `segment.quantile` and `segment.timepoint` cannot be used simultaneously"))
}
#----------------------------------------------------------------------------#
## 3.2 Segment Function (main) ####
#----------------------------------------------------------------------------#
# Drawing segments with different options
if (segment.type == 3){
### 3.2.1 Drawing vertical and horizontal segments ####
if (!is.null(segment.quantile) & is.null(segment.timepoint)){
# Draw vertical Line
segments(x0 = segment_x$quantile,
y0 = 0,
x1 = segment_x$quantile,
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Draw horizontal Line
segments(x0 = 0,
y0 = segment_y,
x1 = segment_x$quantile,
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment (Survival time at specific quantile)
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = quantile_label,
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (is.null(segment.quantile) & !is.null(segment.timepoint)){
# Draw vertical Line
segments(x0 = segment_x,
y0 = 0,
x1 = segment_x,
y1 = segment_y$surv,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Draw horizontal Line
segments(x0 = 0,
y0 = segment_y$surv,
x1 = segment_x,
y1 = segment_y$surv,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = timepoint_label,
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (!is.null(segment.quantile) & !is.null(segment.timepoint)) {
stop("`segment.timepoint` AND `segment.quantile ` not applicable! Choose one of the two options.")
}
} else if (segment.type == 2){
### 3.2.2 Drawing specified segment (half bandwidth) ####
if (!is.null(segment.quantile ) & is.null(segment.timepoint)){
# Horizontal Line
segments(x0 = 0,
y0 = segment_y,
x1 = segment_x$quantile,
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = quantile_label,
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (is.null(segment.quantile ) & !is.null(segment.timepoint)){
# Vertical Line
segments(x0 = segment_x,
y0 = 0,
x1 = segment_x,
y1 = segment_y$surv,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = timepoint_label,
pos = pos,
col = segment.col,
cex = segment.cex,
font = segment.font)
}
} else if (!is.null(segment.quantile) & !is.null(segment.timepoint)) {
stop("`segment.timepoint` AND `segment.quantile ` not applicable! Choose one of the two options.")
}
} else if (segment.type == 1){
### 3.2.3 Drawing specified segment (full bandwidth) ####
if (!is.null(segment.quantile ) & is.null(segment.timepoint)){
# Draw horizontal Line
segments(x0 = 0,
y0 = segment_y,
x1 = max(xticks),
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd )
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = quantile_label,
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (is.null(segment.quantile ) & !is.null(segment.timepoint)){
# Draw vertical Line
segments(x0 = segment_x,
y0 = 0,
x1 = segment_x,
y1 = max(yticks),
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = timepoint_label,
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (!is.null(segment.quantile) & !is.null(segment.timepoint)) {
stop("`segment.timepoint` AND `segment.quantile ` not applicable! Choose one of the two options. ")
}
} else {
stop(paste0("`segment.type`", " = ", segment.type, " is no valid option."))
}
#----------------------------------------------------------------------------#
### 3.3 Segment title ####
#----------------------------------------------------------------------------#
# Title for the segment text
if (!("none" %in% segment.annotation)){
# Display `setment.main` as title of segment annotation if it was specified
if (!is.null(segment.main)){
text(text_xpos, max(text_ypos) + segment.annotation.space, label = segment.main, pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
# Display corresponding title if `segment.quantile` was specified and confidence interval is displayed
} else if (!is.null(segment.quantile) & (segment.confint == T | stratum !=2)){
# For median
if (segment.quantile == 0.5){
text(text_xpos, max(text_ypos) + segment.annotation.space, label = paste0("Median (", conf.int * 100, "% CI)"), pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
# For other quantiles
} else {text(text_xpos, max(text_ypos) + segment.annotation.space, label = paste0(segment.quantile,"-Quantile (", conf.int * 100, "% CI)"), pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
}
# Display corresponding title if `segment.timepoint` was specified and confidence interval is displayed
} else if (!is.null(segment.timepoint) & (segment.confint == T | stratum !=2)){
# If time unit was specified
if(!missing(time.unit)){
time_point_temp <- paste0(" at ", segment.timepoint, " ", time.unit, "s")
} else {
time_point_temp <- paste0(" at time ", segment.timepoint)
}
text(text_xpos, max(text_ypos) + segment.annotation.space, label = paste0(segment.quantile,"Survival", time_point_temp), pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
}
}
#----------------------------------------------------------------------------#
# 4. survStats ####
#----------------------------------------------------------------------------#
# Stop function if stat = coxph or coxph_logrank is chosen
# but number of arms is unequal 2
if ((stat == "coxph" | stat == "coxph_logrank") & stratum != 2) {
stop("It is not possible to set `stat` equal to `coxph` or`coxph_logrank`
if number of arms is unequal 2.")
}
#----------------------------------------------------------------------------#
## 4.1 Stat position ####
#----------------------------------------------------------------------------#
# Define different options for stat position
if (length(stat.position) == 2){
# If it's a numeric vector (x, y coordinates)
stat_xpos <- stat.position[1]
stat_ypos <- stat.position[2]
# Position the text to the right of the specified (x,y)
pos <- 1
} else if (stat.position == "bottomleft"){
if(stat == "coxph_logrank") {
stat_ypos <- 0.08
} else {
stat_ypos <- 0.05
}
stat_xpos <- min(xticks)
pos <- 4
} else if (stat.position == "left"){
stat_ypos <- 0.53
stat_xpos <- min(xticks)
pos <- 4
} else if (stat.position == "right"){
stat_ypos <- 0.53
stat_xpos <- max(xticks)
# Position the text to the left of the specified (x,y)
pos <- 2
} else if (stat.position == "bottomright"){
if(stat == "coxph_logrank") {
stat_ypos <- 0.08
} else {
stat_ypos <- 0.05
}
stat_xpos <- max(xticks)
pos <- 2
} else if (stat.position == "top"){
stat_ypos <- max(yticks) * 0.95
stat_xpos <- max(xticks) * 0.5
pos <- 1
} else if (stat.position == "topright"){
stat_ypos <- max(yticks) * 0.95 # marginal smaller than max(x.ticks) to ensure that the text is not cut off.
stat_xpos <- max(xticks)
pos <- 2
}
#----------------------------------------------------------------------------#
## 4.2 Recalculate Stat ####
#----------------------------------------------------------------------------#
# Recalculate the stat.fit object based on defined 'reference.arm'
if(!missing(reference.arm) & !missing(stat.fit)){
data <- as.data.frame(eval(stat.fit$call$data))
arm.variable <- as.character(fit$call$formula[3])
data[,arm.variable] <- relevel(as.factor(data[,arm.variable]), ref = reference.arm)
stat.fit$call$data <- data
stat.fit <- eval(stat.fit$call)
}
#----------------------------------------------------------------------------#
### 4.2.1 Log rank test ####
#----------------------------------------------------------------------------#
# To compare the survival curves of two or more groups
if(missing(stat.fit)){
logrank <- fit$call
} else {
logrank <- stat.fit$call
}
logrank$conf.type <- NULL
logrank$conf.int <- NULL
logrank[1] <- call("survdiff")
# Check first if strata > 1
# VSO (09.04.2024) Wird schon im 4.) kontrolliert, sollten wir das streichen.
if(is.null(fit$strata)){
logrank <- NULL
} else {
logrank <- eval(logrank)
# Recalculating p-Value
logrankpval <- as.numeric(format.pval(1 - pchisq(logrank$chisq, df = length(logrank$n) - 1), esp = 0.001))
logrankpval <- round.pval(logrankpval)
}
#----------------------------------------------------------------------------#
### 4.2.2 Cox regression ####
#----------------------------------------------------------------------------#
# To describe the effect of variables on survival
# To compare the survival curves of two or more groups
if(missing(stat.fit)){
model <- fit$call
} else {
model <- stat.fit$call
}
model$conf.type <- NULL
model$conf.int <- NULL
model[1] <- call("coxph")
model <- summary(eval(model), conf.int = stat.conf.int)
#----------------------------------------------------------------------------#
## 4.3 Stat Function (main) ####
#----------------------------------------------------------------------------#
# Display statistics in the plot
if(stat == "logrank"){
stats <- paste0("Logrank test: ", logrankpval)
} else if(stat == "coxph"){
stats <- paste0("HR ",
round(model$conf.int[,"exp(coef)"], digits = 2),
" (", stat.conf.int*100, "% CI: ",
round(model$conf.int[3], digits = 2),
" to ",
round(model$conf.int[4], digits = 2),
")")
} else if(stat == "coxph_logrank"){
stats <- paste0("HR ",
round(model$conf.int[,"exp(coef)"], digits = 2),
" (", stat.conf.int*100, "% CI: ",
round(model$conf.int[3], digits = 2),
" to ",
round(model$conf.int[4], digits = 2),
")", "\n", "logrank test: ",
logrankpval)
}
if (stat != "none"){
# Annotate the stats in the plot when stat = "coxph, loglik etc.
text(x = stat_xpos,
y = stat_ypos,
labels = stats,
pos = pos,
col = stat.col,
cex = stat.cex,
font = stat.font)
}
#----------------------------------------------------------------------------#
# 5. survRisktable ####
#----------------------------------------------------------------------------#
if(is.logical(risktable)){
if (risktable == TRUE){
#----------------------------------------------------------------------------#
### 5.1 Extract data ####
#----------------------------------------------------------------------------#
obsStrata <- if(is.null(fit$strata)){
obsStrata <- 1
} else {
obsStrata <- fit$strata
}
grp <- rep(1:stratum, times=obsStrata)
# Initialize a matrix 'n.risk.matrix' with zeros
n.risk.matrix <- matrix(0,nrow = length(xticks), ncol = stratum)
# Loop over each stratum and each time point defined by 'xticks'
for (stratum_i in 1:stratum) {
for (x in 1:length(xticks)) {
# Find the indices where the survival time for the current group is
# greater than the current 'xticks'
index <- which(fit$time[grp == stratum_i] > xticks[x])
# If there are no such indices,
# set the corresponding element in 'n.risk.matrix' to 0
if (length(index) == 0)
n.risk.matrix[x,stratum_i] <- 0
else
# Otherwise, set the element to the minimum number at risk
# for the specified group and time point
n.risk.matrix[x,stratum_i] <- fit$n.risk[grp == stratum_i][min(index)]
}
}
#----------------------------------------------------------------------------#
### 5.1.1 Add risktable.title text to the outer margin ####
#----------------------------------------------------------------------------#
mtext(risktable.title, side = 1, outer = FALSE,
line = risktable.pos, adj = 0, at = risktable.title.position,
font = risktable.title.font,
cex = risktable.title.cex,
col = risktable.title.col)
#----------------------------------------------------------------------------#
### 5.1.2 Add legend text to the outer margin for each stratum ####
#----------------------------------------------------------------------------#
if (missing(risktable.name)) {
ristkable.name <- legend.name
} else {
ristkable.name <- risktable.name
}
if(stratum > 1){
for (i in 1:stratum){
mtext(text = ristkable.name[i], side = 1, outer = FALSE,
line = i+risktable.pos, adj = 0, at = risktable.name.position,
font = risktable.name.font,
cex = risktable.name.cex,
col = risktable.name.col)
}
}
#----------------------------------------------------------------------------#
### 5.1.3 Add vector of risk counts text to the margin ####
#----------------------------------------------------------------------------#
if(max(risktable.col == TRUE)) { risktable.col <- col}
mtext(text = as.vector(n.risk.matrix), side = 1, outer = FALSE,
line = rep((1:stratum) + risktable.pos, each = length(xticks)),
at = rep(xticks, stratum),
cex = risktable.cex,
col = c(rep(risktable.col, each = length(xticks)))
)
}
} else {
stop("`risktable` expecting TRUE or FALSE as an argument!")
}
} # final closer of the function
surv.plot(S2, segment.timepoint=8, segment.annotation = "top", y.unit = "percent")
# segment.timepoint
surv.plot(S1, segment.timepoint=8)
surv.plot(S1, segment.timepoint=8, segment.quantile=0.5)
# segment.timepoint
surv.plot(S1, segment.timepoint=8)
surv.plot(S1, segment.timepoint=8, segment.quantile=0.5)
surv.plot(S1, segment.timepoint=8, segment.type = 2)
surv.plot(S1, segment.timepoint=8, segment.annotation = "bottomleft")
surv.plot(S1, segment.timepoint=8, y.unit = "percent")
surv.plot(S1, segment.timepoint=8, y.unit = "percent", segment.annotation = "bottomleft")
surv.plot(S2, segment.timepoint=8, y.unit = "percent", segment.annotation = "bottomleft")
surv.plot(S1, segment.timepoint=8, segment.annotation = "top")
surv.plot(S2, segment.timepoint=8, segment.annotation = "top")
surv.plot(S2, segment.timepoint=8, segment.annotation = "top", y.unit = "percent")
surv.plot(S1, segment.timepoint=8, segment.annotation = "top", time.unit = "month")
surv.plot(S1, segment.timepoint=8, segment.annotation = "top", time.unit = "month", y.unit = "percent")
surv.plot(S2, segment.timepoint=8, segment.annotation = "top")
surv.plot(S2, segment.timepoint=8, segment.annotation = "top", segment.main = "Survival test")
surv.plot(S2, segment.timepoint=8, segment.annotation = "top", segment.confint = F)
surv.plot(S2, segment.timepoint=8, segment.annotation = "top", y.unit = "percent", segment.confint = F)
surv.plot(S2, segment.timepoint=8, segment.annotation = "top", y.unit = "percent", segment.confint = F, time.unit = "month")
?phantom
getwd()
