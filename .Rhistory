x_coordinates[length(x_coordinates)] <- x_values[length(x_values)]
x_coordinates <- c(x_coordinates, rev(x_coordinates))
# Extract y_coordiantes_lwr from surfvit object(lower)
lower <- fit$lower[(mapping[i]+1):mapping[i+1]]
# Creates empty vector to store y coordiantes
y_coordinates_lwr <- rep(NA, length(lower)*2)
# Put the same 'lower' in two subsequent element of the vector
y_coordinates_lwr[seq(1, length(lower)*2, 2)] <- lower
y_coordinates_lwr[seq(2, length(lower)*2, 2)] <- lower
# Extract y_coordinates_upr from survfit object(upper)
upper <- fit$upper[(mapping[i]+1):mapping[i+1]]
# Creates empty vector to store y coordinates
y_coordinates_upr <- rep(NA, length(upper)*2)
# Put the same 'upper' in two subsequent element of the vector
y_coordinates_upr[seq(1, length(upper)*2, 2)] <- upper
y_coordinates_upr[seq(2, length(upper)*2, 2)] <- upper
# Combine both y_coordinates
y_coordinates <- c(y_coordinates_lwr, rev(y_coordinates_upr))
y_coordinates[is.na(y_coordinates)] <- min(lower,na.rm = T)
# Draw CI band
if(is.null(conf.band.col)){
graphics::polygon(
x = x_coordinates,
y = y_coordinates,
col = adjustcolor(col = col[i],
alpha.f =  conf.band.alpha),
border = FALSE)
}
else{
graphics::polygon(
x = x_coordinates,
y = y_coordinates,
col = adjustcolor(col = conf.band.col[i],
alpha.f =  conf.band.alpha),
border = FALSE)
}
}
}
## Add legend to plot  ####
if (is.logical(show.legend)){
if(show.legend == TRUE){
graphics::legend(
x = legend.position[1],   # the x coordinates to position the legend
y = legend.position[2],             # the y coordinates to position the legend
legend = legend.name ,            # the text of the legend
bty = "n",                          # boarder type for legend fixed as "none"
col = col,
lty = "solid",                      # line type for legend fixed as "solid"
text.font = legend.text.font,
title = legend.title,
cex = legend.cex,
title.cex = legend.title.cex
)
}
} else {
stop("`show.legend` expecting TRUE or FAlSE as an argument!")
}
# 3.SURV.SEGMENT ####
## Define different options to display the segment text  ####
if (length(segment.annotation) == 2) {
# Checks if it's a numeric vector (x, y coordinates)
text_xpos <- segment.annotation[1]
text_ypos <- segment.annotation[2]
# Position the text to the right of the specified (x,y)
pos = 4
} else if (segment.annotation == "bottomleft") {
text_ypos <- 0.03
text_xpos <- min(xlim)
pos <- 4
} else if (segment.annotation == "left"){
text_ypos <- 0.53
text_xpos <- min(xlim)
pos <- 4
} else if (segment.annotation == "right"){
text_ypos <- 0.53
text_xpos <- max(xlim)
# Position the text to the left of the specified (x,y)
pos <- 2
}
## Determining the y coordinate for each text ####
if (stratum == 1){
text_ypos[i] <- text_ypos
} else {
for (i in stratum-1){
text_ypos[i+1] <- text_ypos[i]+ segment.annotation.space
}
}
## Main Segment Function ####
if (segment.type == 3){
### Type 3: Drawing vertical and horizontal segments ####
if (!is.null(segment.quantile) & is.null(segment.timepoint)){
# Code for segment at a specific quantile
segment_y <- segment.quantile
segment_x <- quantile(fit,probs = 1 - segment_y)
# Draw vertical Line
segments(x0 = segment_x$quantile,
y0 = 0,
x1 = segment_x$quantile,
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Draw horizontal Line
segments(x0 = 0,
y0 = segment_y,
x1 = segment_x$quantile,
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment (Survival time at specific quantile)
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = paste0(round(segment_x$quantile,digits = 2),
" [",
round(segment_x$lower,digits = 2),
",",
round(segment_x$upper,digits = 2),
"]"),
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (is.null(segment.quantile) & !is.null(segment.timepoint)){
# Code for segment at a specific time point
segment_x <- segment.timepoint
segment_y <- summary(fit,time = segment_x)
# Draw vertical Line
segments(x0 = segment_x,
y0 = 0,
x1 = segment_x,
y1 = segment_y$surv,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Draw horizontal Line
segments(x0 = 0,
y0 = segment_y$surv,
x1 = segment_x,
y1 = segment_y$surv,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = paste0(round(segment_y$surv, digits = 2),
" [",
round(segment_y$lower, digits = 2),
",",
round(segment_y$upper, digits = 2),
"]"),
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (!is.null(segment.quantile) & !is.null(segment.timepoint)) {
stop("`segment.timepoint` AND `segment.quantile ` not applicable! Choose one of the two options.")
}
} else if (segment.type == 2){
### Type 2: Draw specified segment ####
if (!is.null(segment.quantile ) & is.null(segment.timepoint)){
# Code for segment at a specific quantile
segment_y <- segment.quantile
segment_x <- quantile(fit,probs = 1 - segment_y)
# Horizontal Line
segments(x0 = 0,
y0 = segment_y,
x1 = segment_x$quantile,
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = paste0(round(segment_x$quantile,digits = 2),
" [",
round(segment_x$lower,digits = 2),
",",
round(segment_x$upper,digits = 2),
"]"),
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (is.null(segment.quantile ) & !is.null(segment.timepoint)){
# Code for segment at a specific time point
segment_x <- segment.timepoint
segment_y <- summary(fit,time = segment_x)
# Vertical Line
segments(x0 = segment_x,
y0 = 0,
x1 = segment_x,
y1 = segment_y$surv,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = paste0(round(segment_y$surv, digits = 2),
" [",
round(segment_y$lower, digits = 2),
",",
round(segment_y$upper, digits = 2),
"]"),
pos = pos,
col = segment.col,
cex = segment.cex,
font = segment.font)
}
} else if (!is.null(segment.quantile) & !is.null(segment.timepoint)) {
stop("`segment.timepoint` AND `segment.quantile ` not applicable! Choose one of the two options.")
}
} else if (segment.type == 1){
### Type 1: Drawing specified segment (full bandwidth) ####
if (!is.null(segment.quantile ) & is.null(segment.timepoint)){
# Code for segment at a specific quantile
segment_y <- segment.quantile
segment_x <- quantile(fit,probs = 1 - segment_y)
# Draw horizontal Line
segments(x0 = 0,
y0 = segment_y,
x1 = max(xlim),
y1 = segment_y,
col = segment.col,
lty = segment.lty,
lwd = segment.lwd )
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = paste0(round(segment_x$quantile,digits = 2),
" [",
round(segment_x$lower,digits = 2),
",",
round(segment_x$upper,digits = 2),
"]"),
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (is.null(segment.quantile ) & !is.null(segment.timepoint)){
# Code for segment at a specific time point
segment_x <- segment.timepoint
segment_y <- summary(fit,time = segment_x)
# Draw vertical Line
segments(x0 = segment_x,
y0 = 0,
x1 = segment_x,
y1 = max(ylim),
col = segment.col,
lty = segment.lty,
lwd = segment.lwd)
# Annotate the segment
if (!("none" %in% segment.annotation)){
text(x = text_xpos,
y = text_ypos,
labels = paste0(round(segment_y$surv, digits = 2),
" [",
round(segment_y$lower, digits = 2),
",",
round(segment_y$upper, digits = 2),
"]"),
pos = pos,
col = segment.annotation.col,
cex = segment.cex,
font = segment.font)
}
} else if (!is.null(segment.quantile) & !is.null(segment.timepoint)) {
stop("`segment.timepoint` AND `segment.quantile ` not applicable! Choose one of the two options. ")
}
}
### Draw title for segment text ####
if (!("none" %in% segment.annotation)){
if (!is.null(segment.main)){
text(text_xpos, max(text_ypos) + segment.annotation.space, label = segment.main, pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
} else if (is.null(segment.main) & !is.null(segment.quantile)){
if (segment.quantile == 0.5){
text(text_xpos, max(text_ypos) + segment.annotation.space, label = paste0("Median [95%]"), pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
} else {text(text_xpos, max(text_ypos) + segment.annotation.space, label = paste0(segment.quantile,"-Quantile [95%]"), pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
}
} else if (is.null(segment.main) & !is.null(segment.timepoint)){
text(text_xpos, max(text_ypos) + segment.annotation.space, label = paste0(segment.quantile,"Survival [95%]"), pos = pos,
col = "black", cex = segment.cex, font = segment.main.font)
}
}
# 4. SURV.STATS ####
## Define different options for stat position ####
if (length(stat.position) == 2){
# If it's a numeric vector (x, y coordinates)
stat_xpos <- stat.position[1]
stat_ypos <- stat.position[2]
# Position the text to the right of the specified (x,y)
pos <- 4 #vorher 1
} else if (stat.position == "bottomleft"){
stat_ypos <- 0.03
stat_xpos <- min(xlim)
pos <- 4
} else if (stat.position == "left"){
stat_ypos <- 0.53
stat_xpos <- min(xlim)
pos <- 4
}else if (stat.position == "right"){
stat_ypos <- 0.53
stat_xpos <- max(xlim)
# Position the text to the left of the specified (x,y)
pos <- 2
}
## Log rank test ####
# To compare the survival curves of two or more groups
logrank <- fit$call
logrank$conf.type <- NULL
logrank$conf.int <- NULL
logrank[1] <- call("survdiff")
# Check first if strata > 1
if(is.null(fit$strata)){
logrank <- NULL
} else {
logrank <- eval(logrank)
# Recalculating p-Value
logrankpval <- as.numeric(format.pval(1 - pchisq(logrank$chisq, df = length(logrank$n) - 1), esp = 0.001))
logrankpval <- round.pval(logrankpval)
}
## Cox proportional hazard regression ####
# To describe the effect of variables on survival
model <- fit$call
model$conf.type <- NULL
model$conf.int <- NULL
model[1] <- call("coxph")
model <- summary(eval(model))
## Display statistics in the plot ####
if(stat == "logrank"){
stats <- paste0("Logrank test: ", logrankpval)
} else if(stat == "coxph"){
stats <- paste0("HR ",
round(model$conf.int[,"exp(coef)"], digits = 2),
" (95% CI: ",
round(model$conf.int[,"lower .95"], digits = 2),
" to ",
round(model$conf.int[,"upper .95"], digits = 2),
")")
} else if(stat == "coxmodel"){
if("right" %in% stat.position){
# table is always written from the specified x,y pos from left to right
# therefore stat.positon="right" position is outside of the border.
# It has to be corrected for tables.
# Extract infos and create data frame from model
tbl <- data.frame(N = model$n,
Events = model$nevent,
HR = round(model$conf.int[,"exp(coef)"], digits = 2),
lwrCI = round(model$conf.int[,"lower .95"], digits = 2),
uprCI = round(model$conf.int[,"upper .95"], digits = 2),
Logrank = logrankpval)
# Annotation
# plottbl() function was written to allow to plot different tables reproducible
plottbl(x = stat_xpos - max(xlim)/2,
y = stat_ypos,
tbl,
cex = stat.cex)
} else {
# Extract infos and create data frame from model
tbl <- data.frame(N = model$n,
Events = model$nevent,
HR = round(model$conf.int[,"exp(coef)"], digits = 2),
lwrCI = round(model$conf.int[,"lower .95"], digits = 2),
uprCI = round(model$conf.int[,"upper .95"], digits = 2),
Logrank = logrankpval)
# Annotation
# plottbl() function was written to allow to plot different tables reproducible
plottbl(x = stat_xpos,
y = stat_ypos,
tbl,
cex = stat.cex)
}
}
if (stat != "none" && stat != "coxmodel"){
# Annotate the stats in the plot when stat = "coxph, loglik etc.
text(x = stat_xpos,
y = stat_ypos,
labels = stats,
pos = pos,
col = stat.col,
cex = stat.cex,
font = stat.font)
}
# 5. SURV.RISKTABLE ####
if(is.logical(risktable)){
if (risktable == TRUE){
obsStrata <- if(is.null(fit$strata)){
obsStrata <- 1
} else {
obsStrata <- fit$strata
}
grp <- rep(1:stratum, times=obsStrata)
# Initialize a matrix 'n.risk.matrix' with zeros
n.risk.matrix <- matrix(0,nrow = length(xlim), ncol = stratum)
# Loop over each stratum and each time point defined by 'xlim'
for (stratum_i in 1:stratum) {
for (x in 1:length(xlim)) {
# Find the indices where the survival time for the current group is greater than the current 'xlim'
index <- which(fit$time[grp == stratum_i] > xlim[x])
# If there are no such indices, set the corresponding element in 'n.risk.matrix' to 0
if (length(index) == 0)
n.risk.matrix[x,stratum_i] <- 0
else
# Otherwise, set the element to the minimum number at risk for the specified group and time point
n.risk.matrix[x,stratum_i] <- fit$n.risk[grp == stratum_i][min(index)]
}
}
# Set up the plot with margin (ora) and outer margins (oma)
par(mar = c(3 + stratum + 2, 4, 4, 2)+0.1) # c(bottom, left, top, right)
# Add risktable.title text to the outer margin
mtext(risktable.title, side = 1, outer = FALSE,
line = 4, adj = NA, at = risktable.title.position,
font = risktable.title.font,
cex = risktable.cex,
col = risktable.title.col)
# Add legend text to the outer margin for each stratum
for (i in 1:stratum){
mtext(text = legend.name[i], side = 1, outer = FALSE,
line = i+4, adj = NA, at = risktable.name.position,
font = risktable.name.font,
cex = risktable.cex,
col = risktable.name.col)
}
# Add vector of risk counts text to the margin
mtext(text = as.vector(n.risk.matrix), side = 1, outer = FALSE,
line = rep((1:stratum) + 4, each = length(xlim)),
at = rep(xlim, stratum),
cex = risktable.cex,
col = c(rep(risktable.col, each = length(xlim)))
)
}
} else {
stop("`risktable` expecting TRUE or FALSE as an argument!")
}
} # final closer of the function
veteran$time_yr <- veteran$time/365.25
veteran$time_mt <- veteran$time_yr*12
# Define the reference arm
veteran$trt <- factor(veteran$trt,
levels = c(1,2),
labels = c("Standard","Test"))
# Create survival object
veteran_fit_yr <- survfit(Surv(time_yr, status) ~ 1, data = veteran)
veteran_fit_mt <- survfit(Surv(time_mt, status) ~ 1, data = veteran)
veteran_trt_fit_yr <- survfit(Surv(time_yr, status) ~ trt, data = veteran)
veteran_trt_fit_mt <- survfit(Surv(time_mt, status) ~ trt, data = veteran)
# Plot 1
surv.plot(fit = veteran_fit_mt,
risktable = FALSE,
xlim = seq(0,34, by = 3),
xlab = ("Time (month)"),
segment.type = 3,
segment.quantile = 0.5,
segment.annotation.space = 0.06,
segment.cex = 0.6,
)
# Modify Colour
survSAKK::surv.plot(fit = survobject1, col = c("pink", "#666666"))
# Add a title and subtitle
survSAKK::surv.plot(fit = survobject1, main = "KM Curve of the Lung Cancer", sub = "Datasource - NCCTG Lung Cancer Data")
# Rename legend
survSAKK::surv.plot(fit = survobject1,legend.name = c("Male", "Female"))
# Modify x axis
survSAKK::surv.plot(fit = survobject1,legend.name = c("Male", "Female"),
xlim = seq(0,35, 3),
xlab = "Time (Month)")
# Add Segments
# Median
survSAKK::surv.plot(fit = survobject1,legend.name = c("Male", "Female"),
xlim = seq(0,35, 3),
xlab = "Time (Month)",
segment.quantile = 0.5)
# Survival at 12month
survSAKK::surv.plot(fit = survobject1, legend.name = c("Male", "Female"),
xlim = seq(0,35, 3),
xlab = "Time (Month)h",
segment.timepoint = 12,
segment.annotation = "bottomleft")
# Survival at 12month
survSAKK::surv.plot(fit = survobject1, legend.name = c("Male", "Female"),
xlim = seq(0,35, 3),
xlab = "Time (Month)",
segment.timepoint = 12,
segment.annotation = "bottomleft")
# Specifying the location of annotation manually
survSAKK::surv.plot(fit = survobject1, legend.name = c("Male", "Female"),
xlim = seq(0,35, 3),
xlab = "Time (Month)",
segment.timepoint = 12,
segment.annotation = c(3,0.25))
# Add statistics: Cox proportional hazard ratio
survSAKK::surv.plot(fit = survobject1, legend.name = c("Male", "Female"),
xlim = seq(0,35, 3),
xlab = "Time (Month)",
segment.quantile = 0.5,
stat = "coxph",
stat.position = "bottomleft")
